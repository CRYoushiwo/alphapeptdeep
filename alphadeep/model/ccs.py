# AUTOGENERATED! DO NOT EDIT! File to edit: nbdev_nbs/model/ccs.ipynb (unless otherwise specified).

__all__ = ['charge_factor', 'EncDecModelCCS', 'get_reduced_mass', 'ccs_to_mobility_bruker', 'mobility_to_ccs_bruker',
           'ccs_to_mobility_pred_df', 'mobility_to_ccs_df', 'AlphaCCSModel']

# Cell
import torch
import pandas as pd
import numpy as np

from tqdm import tqdm

from alphabase.peptide.fragment import update_precursor_mz

from alphadeep.model.featurize import (
    parse_aa_indices,
    get_batch_mod_feature
)

from alphadeep._settings import model_const

import alphadeep.model.base as model_base

from alphadeep.model.rt import (
    evaluate_linear_regression,
    evaluate_linear_regression_plot
)

charge_factor = model_const['charge_factor']

# Cell
class EncDecModelCCS(torch.nn.Module):
    def __init__(self,
        dropout=0.1
    ):
        super().__init__()

        self.dropout = torch.nn.Dropout(dropout)

        hidden = 256

        self.ccs_encoder = (
            model_base.Input_AA_CNN_LSTM_cat_Charge_Encoder(
                hidden
            )
        )

        self.ccs_decoder = model_base.LinearDecoder(
            hidden+1, 1
        )

    def forward(self,
        aa_indices,
        mod_x,
        charges,
    ):
        x = self.ccs_encoder(aa_indices, mod_x, charges)
        x = self.dropout(x)
        x = torch.cat((x, charges),1)
        return self.ccs_decoder(x).squeeze(1)

# Cell
def get_reduced_mass(precursor_mzs, charges):
    reduced_masses = precursor_mzs*charges
    # 28 is the mass of N(2), the gas in IM instrument
    return reduced_masses*28.0/(reduced_masses+28.0)

def ccs_to_mobility_bruker(ccs_values, charges, precursor_mzs):
    reduced_masses = get_reduced_mass(precursor_mzs, charges)
    # 1059.62245 is the estimated constant coef in Mason Schamp equation of Burker
    # The estimated IM value is very accurate
    return ccs_values*np.sqrt(reduced_masses)/charges/1059.62245

def mobility_to_ccs_bruker(im_values, charges, precursor_mzs):
    reduced_masses = get_reduced_mass(precursor_mzs, charges)
    return im_values*charges*1059.62245/np.sqrt(reduced_masses)

def ccs_to_mobility_pred_df(
    precursor_df:pd.DataFrame
)->pd.DataFrame:
        if 'precursor_mz' not in precursor_df.columns:
            precursor_df = update_precursor_mz(precursor_df)
        precursor_df['mobility_pred'] = ccs_to_mobility_bruker(
            precursor_df.ccs_pred.values,
            precursor_df.charge.values,
            precursor_df.precursor_mz.values
        )
        return precursor_df

def mobility_to_ccs_df(
    precursor_df:pd.DataFrame
)->pd.DataFrame:
        if 'precursor_mz' not in precursor_df.columns:
            precursor_df = update_precursor_mz(precursor_df)
        precursor_df['ccs'] = mobility_to_ccs_bruker(
            precursor_df.mobility.values,
            precursor_df.charge.values,
            precursor_df.precursor_mz.values
        )
        return precursor_df

# Cell

class AlphaCCSModel(model_base.ModelImplBase):
    def __init__(self, dropout=0.1, lr=0.001):
        super().__init__()
        self.build(
            EncDecModelCCS, lr=lr,
            dropout=dropout,
        )
        self.loss_func = torch.nn.L1Loss()
        self.charge_factor = charge_factor

    def _prepare_predict_data_df(self,
        precursor_df:pd.DataFrame,
    ):
        precursor_df['ccs_pred'] = 0.
        self.predict_df = precursor_df

    def _get_features_from_batch_df(self,
        batch_df: pd.DataFrame,
        nAA
    ):
        aa_indices = torch.LongTensor(
            parse_aa_indices(
                batch_df['sequence'].values.astype('U')
            )
        )

        mod_x_batch = get_batch_mod_feature(batch_df, nAA)
        mod_x = torch.Tensor(mod_x_batch)

        charges = torch.Tensor(
            batch_df['charge'].values
        ).unsqueeze(1)*self.charge_factor

        return aa_indices, mod_x, charges

    def _get_targets_from_batch_df(self,
        batch_df: pd.DataFrame,
        nAA
    ) -> torch.Tensor:
        return torch.Tensor(batch_df['ccs'].values)

    def _set_batch_predict_data(self,
        batch_df: pd.DataFrame,
        predicts,
    ):
        predicts[predicts<0] = 0.0
        if self._predict_in_order:
            self.predict_df.loc[:,'ccs_pred'].values[
                batch_df.index.values[0]:batch_df.index.values[-1]+1
            ] = predicts
        else:
            self.predict_df.loc[
                batch_df.index,'ccs_pred'
            ] = predicts

    def ccs_to_mobility_pred(self,
        precursor_df:pd.DataFrame
    )->pd.DataFrame:
        return ccs_to_mobility_pred_df(precursor_df)